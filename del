#!/bin/bash
## **********************************************************************************
## 
## Name:    del
## Author:  Gabriel Gonzalez
## Email:   gabeg@bu.edu
## License: The MIT License (MIT)
## 
## Syntax: del [option] <argument>
##         
## Description: Delete files and move them to the trash can, that way files are not
##              deleted forever.
##              
## Notes: None.
## 
## **********************************************************************************



## ================
## GLOBAL VARIABLES
## ================

## Program information
ARGV=("$@")
PROG_NAME=`basename $0`
PROG_DIR=`echo "$0" | sed "s/\/${PROG_NAME}$//"`

IFS=$'\n'
TRASH_DIR=`head -1 "${PROG_DIR}/trash.config" | sed 's/\/$//'`



## #################################
## ##### TRASH PROGRAM OPTIONS #####
## #################################

## Main function
main() {
    case "${ARGV[0]}" in
        ""|"-h"|"--help") 
            usage
            exit 0
            ;;
        "--setup")
            echo "Where is the trash can located?"
            read -p "> " ans
            
            if [ -z "${ans}" ]; then 
                echo "${PROG_NAME}: No path specified. Skipping trash can setup."
                exit 0
            fi
            
            if [ -d "${ans}" ]; then
                echo "${ans}" > "${TRASH_PREF}"
                echo 
                echo ":: Setting new trash can location...Done."
            else
                echo "${PROG_NAME}: Directory '${ans}' does not exist." 1>&2
                exit 1
            fi
            
            exit 0
            ;;
        "-s"|"--size") 
            size=`du -sh "${TRASH_DIR}" | cut -f1 -d'/'`
            echo "Trash Size:" "${size}"
            exit 0
            ;;
        "*~")
            if [ ! -f "*~" ]; then
                echo "${PROG_NAME}: No backup files found." 1>&2
                exit 1
            fi
            ;;
        "-r"|"--rec"|"--recover")
            recover_file
            exit 0
            ;;
        *) 
            delete_files 
            exit 0
            ;;
    esac
}



## ###############################
## ##### PRINT PROGRAM USAGE #####
## ###############################

## Displays the help screen
usage() {
    echo "Usage: ${PROG_NAME} [option] <argument>"
    echo 
    echo "Options:"
    echo "    --setup                        Setup the trash can path"
    echo "    -s, --size                     Display the size of the trash can"
    echo "    -r, --rec, --recover <file>    Recover a file from the trash can"
    echo 
    echo "Arguments:"
    echo "    <file>                         Input file to recover"
    echo "    <file(s)>                      File(s) to delete"
}



## ####################################
## ##### RECOVER AND DELETE FILES #####
## ####################################

## Delete the specified file(s)
delete_files() {
    now=`date +%b%d--%H:%M:%S`
    
    ## Loop through files to delete
    for i in "${ARGV[@]}"; do
        if [[ "${i}" == "" ]]; then 
            continue
        fi
        
        ## File/directory check
        if [ -f "${i}" ] || [ -d "${i}" ]; then
            if [ -d "${i}" ]; then 
                i=`echo "${i}" | sed -e 's/\/$//'`
            fi
            
            echo -n ":: Deleting ${i}..." 
            mv "${i}" "${TRASH_DIR}/${i}<>${now}" 
            echo "Done"
        else
            echo -e "${PROG_NAME}: File '${i}' does not exist." 1>&2
            exit 1
        fi
    done
}



## Recover the specified file
recover_file() {
    
    ## Display matches
    display_recovery_matches
    read -p '> ' ans
    
    if [ -z "${ans}" ]; then
        echo "${PROG_NAME}: No value specified. Skipping file recovery."
        exit 0
    fi
    
    if "$(is_valid_index "${ans}")"; then
        echo "${PROG_NAME}: Value '${ans}' is invalid." 1>&2
        exit 1
    fi
    
    ## Recover file
    matches=(`get_matches`)
    names=(`echo "${matches[*]}" | cut -f1 -d'<'`)
    i=$[ ${ans} - 1]
    item="${names[${i}]}"
    
    echo 
    echo -n ":: Transferring '${item}' to current directory..."
    mv "${TRASH_DIR}/${matches[${i}]}" "${item}"
    echo "Done"
}



## Display file recovery matches
display_recovery_matches() {
    
    ## File matches
    if [ -z "${ARGV[1]}" ]; then
        echo "${PROG_NAME}: No file specified. Skipping file recovery." 
        exit 0
    fi
    
    matches=(`get_matches`)
    n=${#matches[@]}
    last=$[ ${n} - 1 ]
    
    if [ ${n} -eq 0 ]; then
        echo "${PROG_NAME}: No files matching '${ARGV[1]}' found." 1>&2
        exit 1
    fi
    
    ## Name match and time of deletion 
    names=(`echo "${matches[*]}" | cut -f1 -d'<'`)
    times=(`echo "${matches[*]}" | cut -f2 -d'>' \
                        | sed -e 's/Jan/Jan /' -e 's/Feb/Feb /' -e 's/Mar/Mar /' \
                              -e 's/Apr/Apr /' -e 's/May/May /' -e 's/Jun/Jun /' \
                              -e 's/Jul/Jul /' -e 's/Aug/Aug /' -e 's/Sep/Sep /' \
                              -e 's/Oct/Oct /' -e 's/Nov/Nov /' -e 's/Dec/Dec /' \
                        | sed 's/--/ - /'`)
    
    ## Get string padding
    len=0
    for i in `seq 0 ${last}`; do
        j=$[ ${i} + 1 ]
        item="${names[${i}]}"
        
        if [ ${#item} -gt ${len} ]; then len=$[ ${#item} + 3 ]; fi
    done
    
    ## Display file matches
    echo "Which file would you like to recover?"
    
    for i in `seq 0 ${last}`; do
        j=$[ ${i} + 1 ]
        item="${names[${i}]}"
        
        if [ -d "${TRASH_DIR}/${matches[${i}]}" ]; then 
            item="${item}/"
        fi
        
        printf "%s: %-${len}s %s" "${j}" "${item}" "${times[${i}]}" \
            | GREP_COLORS='mt=00;32' \
              grep --color=always -E '^.*: '
    done
}



## ###################################
## ##### FILE RECOVERY UTILITIES #####
## ###################################

## Return files that match recovery file
get_matches() {
    ls -1 -A "${TRASH_DIR}" | grep --color=never -i "${ARGV[1]}"
}



## Check if match array index is valid
is_valid_index() {
    matches=(`get_matches`)
    n=${#matches[@]}
    flag=false
    
    if [ "$1" -eq "$1" ] 2> /dev/null; then 
        :
    else 
        flag=true
    fi
    
    if [ "$1" -le 0 -o "$1" -gt "${n}" ]; then
        flag=true
    fi
    
    echo "${flag}"
}



## ============
## Execute Main
## ============
 
main 

#!/bin/bash
# ******************************************************************************
# 
# Name:    del
# Author:  Gabriel Gonzalez
# Email:   gabeg@bu.edu
# License: The MIT License (MIT)
# 
# Syntax: del [option] <args>
#         
# Description: Delete files and move them to the trash can, that way files are
#              not deleted forever.
#              
# Notes: None.
# 
# ******************************************************************************

# Globals
PROG="${0##*/}"
PROGDIR=$(dirname "$(readlink -f "${0}")")
TRASHDIR="${HOME}/.local/share/trash"

# Options
VERBOSE=true

# Source utility
. "${PROGDIR}/../lib/bash/util.sh"

# Exit statuses
ENOTRASH=10
ERECVR=11

# ******************************************************************************
# Main
main()
{
    # No arguments
    if [ $# -eq 0 ]; then
        usage
        exit 0
    fi

    short="hqd:r:psl"
    long="help,quiet,install,uninstall,empty,delete,recover,print,size,list"
    opts=$(getopt -o "${short}" --long "${long}" --name "${PROG}" -- "${@}")

    # Invalid arguments
    if [ $? -ne 0 ]; then
        usage
        exit 1
    fi

    # Options
    local INSTALL=
    local UNINSTALL=
    local EMPTY=
    local DELETE=
    local RECOVER=
    local PRINT=
    local SIZE=
    local LIST=
    local FILE=
    local PARSED=

    # Parse options
    eval set -- "${opts}"
    while true; do
        case "${1}" in
            # Usage
            -h|--help)
                usage
                exit 0
                ;;

            # Quiet
            -q|--quiet)
                VERBOSE=
                ;;

            # Install
            --install)
                INSTALL=true
                check_multi_arg "${INSTALL}" "install trash can"
                ;;

            # Uninstall
            --uninstall)
                UNINSTALL=true
                check_multi_arg "${UNINSTALL}" "uninstall trash can"
                ;;

            # Empty trash
            --empty)
                EMPTY=true
                check_multi_arg "${EMPTY}" "empty trash can"
                ;;

            # Delete file(s)
            -d|--delete)
                shift
                DELETE=true
                FILE=("${@}")
                check_multi_arg "${DELETE}" "delete file(s)"
                ;;

            # Recover file
            -r|--recover)
                shift
                RECOVER=true
                FILE="${1}"
                check_multi_arg "${RECOVER}" "recover a file"
                ;;

            # Print location of trash
            -p|--print)
                PRINT=true
                check_multi_arg "${PRINT}" "print location of trash"
                ;;

            # Size of trash
            -s|--size)
                SIZE=true
                check_multi_arg "${SIZE}" "display size of trash"
                ;;

            # List trash contents
            -l|--list)
                LIST=true
                check_multi_arg "${LIST}" "list trash can contents"
                ;;

            # End of options
            --)
                break
                ;;
        esac
        shift
        PARSED=true
    done

    # Run options
    if [ -z "${PARSED}" ]; then
        print_err "No options specified. See '--help' for more information."
        exit ${EARG}
    elif [ -n "${INSTALL}" ]; then
        run_install
    else
        if [ ! -d "${TRASHDIR}" ]; then
            print_err "Trash has not been installed yet. See --install for more info."
            exit ${ENOTRASH}
        fi

        if [ -n "${UNINSTALL}" ]; then
            run_uninstall
        elif [ -n "${EMPTY}" ]; then
            empty_trash
        elif [ -n "${DELETE}" ]; then
            delete_files "${FILE[@]}"
        elif [ -n "${RECOVER}" ]; then
            recover_file "${FILE}"
        elif [ -n "${PRINT}" ]; then
            print_trash_dir
        elif [ -n "${SIZE}" ]; then
            print_trash_size
        elif [ -n "${LIST}" ]; then
            list_trash_contents
        else
            :
        fi
    fi
}

# ******************************************************************************
# Print program usage
usage()
{
    echo "Usage: ${PROG} [options] <args>"
    echo
    echo "Options:"
    echo "    -h, --help"
    echo "        Print program usage."
    echo
    echo "    -q, --quiet"
    echo "        Quiet output."
    echo
    echo "    --install"
    echo "        Install trash."
    echo
    echo "    --uninstall"
    echo "        Uninstall trash."
    echo
    echo "    --empty"
    echo "        Empty the trash."
    echo
    echo "    -d, --delete <file(s)>"
    echo "        Delete one or more files."
    echo
    echo "    -r, --recover <file>"
    echo "        Recover a file from trash."
    echo
    echo "    -p, --print"
    echo "        Print location of trash."
    echo
    echo "    -s, --size"
    echo "        Display size of trash."
    echo
    echo "    -l, --list"
    echo "        List contents of trash."
    echo
    echo "Arguments:"
    echo "    <file>"
    echo "        File to recover."
    echo
    echo "    <file(s)>"
    echo "        One or more files to delete."
}

# ******************************************************************************
# Install
run_install()
{
    print_info "Installing trash can at: '${TRASHDIR}'."
    mkdir -p "${TRASHDIR}"
}

# ******************************************************************************
# Uninstall
run_uninstall()
{
    print_info "Uninstalling trash can at: '${TRASHDIR}'."
    rm -rf "${TRASHDIR}"
}

# ******************************************************************************
# Empty trash can
empty_trash()
{
    echo "Are you sure you want to empty the trash can?"
    read -p "> " ans

    case "${ans}" in
        y|Y|yes|Yes|YES)
            print_info "Emptying trash can."
            rm -rf "${TRASHDIR}"/*
            ;;

        *)
            print_info "Exiting."
            exit ${ENORM}
            ;;
    esac
}

# ******************************************************************************
# Delete file(s)
delete_files()
{
    local dir="${TRASHDIR}/$(date +%Y-%m-%d)"
    local now=$(date +%H%M%S)

    for f in "${@}"; do
        # Check file/directory
        if [ "${f}" == "--" ]; then
            continue
        fi
        if [ ! -e "${f}" ]; then
            print_err "Skipping '${f}': File does not exist."
            continue
        fi

        # Move to trash
        if [ ! -d "${dir}" ]; then
            mkdir -p "${dir}"
        fi

        print_info "Deleting '${f}'."
        mv "${f}" "${dir}/$(basename "${f}")-${now}"
    done
}

# ******************************************************************************
# Recover a file
recover_file()
{
    local file="${1}"
    local IFS=$'\n'
    local matches=

    # Check matches
    matches=($(get_recovery_matches "${file}"))
    if [ $? -ne 0 ]; then
        print_err "No files matching '${ARGV[1]}' found."
        exit ${ERECVR}
    fi

    # Prompt for file to recover
    echo "Which file would you like to recover?"
    echo
    echo "${matches[*]}"
    read -p "> " ans

    # Check input values
    if [ -z "${ans}" ]; then
        print_info "Exiting."
        exit ${ENORM}
    fi
    if is_integer "${ans}" && \
        [ ${ans} -ge 1 -a ${ans} -le ${#matches[@]} ]
    then
        :
    else
        print_err "Unable to recover file: Invalid value entered."
        exit ${ERECVR}
    fi

    # Recover file
    local line="${matches[$[${ans}-1]]}"
    local dir=$(echo "${line}" | awk '{ print $2 }')
    local IFS=$'|'
    local linesplit=(${line})
    local trashfile=$(echo "${linesplit[1]:1}" | cut -f1 -d'/')
    local recfile="${trashfile:0:$[${#trashfile}-7]}"

    print_out 
    print_info "Recovering '${trashfile}'."
    mv "${TRASHDIR}/${dir}/${trashfile}" ./"${recfile}"
}

# ******************************************************************************
# Print trash directory
print_trash_dir()
{
    echo "Trash Directory: '${TRASHDIR}'"
}

# ******************************************************************************
# Print trash size
print_trash_size()
{
    echo "Trash Size: $(get_trash_size)"
}

# ******************************************************************************
# List trash contents
list_trash_contents()
{
    builtin cd "${TRASHDIR}"
    find *
}

# ******************************************************************************
# Return size of trash
get_trash_size()
{
    du -sh "${TRASHDIR}" 2> /dev/null | awk '{ print $1 }'
}

# *******************************************************************************
# Display file recovery matches
get_recovery_matches()
{
    local file="${1}"
    local IFS=$'\n'
    local matches=($(get_file_matches "${1}"))

    # Check matches
    if [ ${#matches[@]} -eq 0 ]; then
        return ${ERECVR}
    fi

    # Print matches
    local i=1
    local offset=11
    local timestamp=
    local tt=
    local name=

    for f in "${matches[@]}"; do
        name=$(echo "${f:${offset}}" | cut -f1 -d'/')
        tt="${name:$[${#name}-6]:6}"
        timestamp="${f:0:10} ${tt:0:2}:${tt:2:2}:${tt:4:2}"
        printf "%d: %s | %s\n" "${i}" "${timestamp}" "${f:${offset}:$[${#f}-${offset}]}"
        i=$[ ${i} + 1 ]
    done
}

# ******************************************************************************
# Return files that match recovery file
get_file_matches()
{
    builtin cd "${TRASHDIR}"
    find * -name "*${1}*"
}

# ******************************************************************************
# Check if multiple arguments are used when they should not be
check_multi_arg()
{
    local opt="${1}"
    local desc="${2}"
    local args="${INSTALL}${UNINSTALL}${EMPTY}${DELETE}${RECOVER}${PRINT}${SIZE}${LIST}"

    if [ "${opt}" != "${args}" ]; then
        print_err "Unable to ${desc}: Must specify only one option."
        exit ${EARGS}
    fi
}

# ******************************************************************************
# Execute main
main "${@}"
